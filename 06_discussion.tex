\section{Discussion} \label{sec:discussion}

%\shortsection{Adaptability}\label{sec:adaptability}
We have demonstrated our decentralized certificate authority using secure two-party computation with the signing algorithm ECDSA on the curve \texttt{secp192k1} as a proof-of-concept. The prototype can be expanded to work on positive curve parameters of any size without any change to the code, and it would be straightforward to implement other signing algorithms such as DSA this way (although the actual practicality of implementing other algorithms within an MPC would depend on the computation required). Below we mention some suggestions and possible modifications for efficiency and wider adaptability of our current scheme.

%\bnote{Verifiable Covert by Vlad Kolsnikov - alternative to dualex, maybe mention in related works?}
\shortsection{Other Security Models} Though we achieve secure two-party signing in the presence of malicious adversaries, our dual execution based signing costs double than that of Yao's protocol based signing. An alternative would be to use the more efficient protocol of Kolesnikov and Malozemoff~\cite{kolesnikov2014public}, which provides a slightly weaker notion of publicly-verifiable covert security, but is practical and achieves efficiency close to that of semi-honest protocols. Covert adversaries~\cite{aumann2007security} can deviate from the protocol like malicious adversaries, but are caught by the honest party with a fixed probability. Asharov and Orlandi~\cite{asharov2012calling} modified this definition by making the detection of covert adversaries publicly verifiable, thereby making this security notion more practical and widely applicable. This scheme is improved upon by Kolesnikov and Malozemoff, making it more efficient by replacing the original oblivious transfer~\cite{peikert2008framework} in the scheme with the more efficient oblivious transfer extension protocol~\cite{asharov2015more}. The drawback of using this model, however, it is provides no limit on the leakage that might be obtained before the adversary is caught. Without a strong revocation mechanism, this would have a high risk in our application since a malicious host could potentially obtain the other host's key share, and generate fraudulent certificates that would be trusted by browsers even if the malicious activity is detected.

%\dnote{need to discuss honest-majority models (which are much less expensive, and probably well justified for some scenarios, definitely for \#1) in related work - this is different from increasing number of parties with an all-but-self-dishonest model}



\shortsection{Extending to Three-Party Setting} Our work has focused on the two-party setting, which we believe is simplest to deploy and reason about. There are very efficient MPC protocols know for three-party models where it is assumed that two of the parties are honest. For example, Araki et al.~\cite{araki2016high} propose a three-party scheme for distributed AES encryption and distributed ticket generation in Kerberos in the presence of a corrupt/malicious party. Launchbury et al.~\cite{launchbury2012efficient} and Laur et al.~\cite{laur2013oblivious} also provide efficient implementations of distributed AES encryption with honest majority. Any of these schemes could be used for extending distributed certificate authority to three-party setting with an honest majority.
%\dnote{highlight Araki and other results on this}. \dnote{I don't think rest of paragraph here makes sense, need to worry about 2 parties colluding in these models}

%Modifying our current prototype to support more than two parties such as Araki et al.'s three-party computation protocol ~\cite{araki2016high} would guarantee secure certificate signing when there is an honest majority of CA machines. This is beneficial to our first scenario where multiple machines are used for signing withing a certificate authority's organization, as allowing the participation of multiple machines increases the privacy and fault tolerance in the signing process. Moreover, extending the protocol of Araki et al. will allow us to perform certificate signing even in the presence of malicious adversaries, as long as there is an honest majority of participants. In contrast, the dual execution is only applicable to two-party setting.

\shortsection{Deployment}
In Section~\ref{sec:scenarios}, we explained the setups for our decentralized CAs. Deployment of our designs would require some out-of-band changes on the current certificate chain and its validation process. First, browsers would need to add a new class of certificate, the joint validation certificate, %\hnote{maybe we need a better name}
analogous to the current extended validation certificate (EV) (Section~\ref{sec:certificate_issuance_process}). 

In the first scenario of a single CA signing the certificate internally, the only change that the CA would need to make is to submit its new certificate to the browser. In the second scenario where two individual CAs are involved, the joint signing key would need to be trusted by the browser. Ideally, this could be a built-in root key in the browser so there is no reliance on a separate root key. For immediate deployment, however, it could be validated as part of a certificate chain.

In the third scenario, each subject-$CA_s$ pair has their own set of certificates. Since it would not be practical to include the certificate for every subject-$CA_s$ pair in the browser, we could use alternative measures to track subject-$CA_s$ certificates and ensure that CA-only certificates for the subject will not be trusted. 
The first idea is to use a certificate transparency log, where certificates are publicly logged by CAs and browsers as they are issued and observed as to easily audit and mitigate attempts of misuse~\cite{certificate_transparency}. A simpler solution is public key pinning~\cite{public_key_pinning}, which associates a host directly with its certificate or public key before the deployment of the browser or when the browser first encounters the host.  Once a subject has pinned its key using a subject-$CA_s$ certificate, it is protected with this client from a certificate generated independently by the CA.

%\dnote{We can keep a discussion section, but it should be more about out-of-band issues for protocol: what would need to change in clients for subject-CA to work (need to know to reject plain CA certs), how this relates to cert transparency, pinning, etc. - those could be in related work, liability issues, etc.}
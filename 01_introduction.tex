\section{Introduction}  \label{sec:introduction}

The security of the web heavily relies on anchoring trust on the certificate authorities. Although widely-trusted CAs take extraordinary efforts to protect their private keys, compromises and abuses still occur, with disastrous consequences. 
Roosa and Schultze~\cite{roosa2013trust} discussed attacks on certificate authorities where the attacker either takes control of the CA or colludes to obtain certificates trusted by a client's browser.  As an example, an attack on Comodo's registration authority (RA) allowed the attacker to obtain a domain validation (DV) certificate for Google~\cite{attack_from_iran}. An attacker exploited a subCA of DigiNotar  to obtain several extended validation (EV) certificates~\cite{diginotar_hack_highlights}. EV certificates provide access to high security HTTPS websites, and hence their leakage is more serious compared to the leakage of DV certificates. 

Certificate authorities are at risk of not just compromise, but also internal misuse and mistakes. Notably, Symantec has issued certificates without carefully verifying the domain and expiration date or reviewing the certificate recipient's application~\cite{symantec_issues_wiki}. In 2015, Symantec mistakenly issued test certificates for a number of domains, including \domain{www.google.com}, without the permission of the domain holders. In response to suspicion that Symantec has allegedly mis-issued more than 30,000 certificates, Google Chrome recently announced plans on restricting certificates issued by Symantec-owned issuers~\cite{google_takes_symantec}. Free open certificate authority 
Let's Encrypt, which provides free certificates to requesters using an automated domain validation protocol, has been criticized for issuing TLS/SSL certificates to 15,270 sites containing the keyword \domain{paypal.com} which were obtained for use in phishing attacks~\cite{lets_encrypt_paypal}. %These are examples of the different types of mistakes that can occur when a single CA is responsible for issuing certificates.
%\TODO{also add discussion of recent incidents with Symantec and google - this is evidence of risk of not just compromise, but internal misuse/mistakes}  
%\TODO{to justify multi-policy CAs, could also mention issue letsencrypt has with fake paypal certs}

The above attacks are possible due to single point-of-failure where the certificate signature generation depends on a single private key owned by a single CA. This key is stored in a physical file that could be compromised by an outside attacker exploiting software vulnerabilities, by an attacker who obtains physical access to the stored key, or by insiders who have access to it within the organization. Our goal is to provide a mechanism to reduce the single point-of-failure risks inherent in current CAs.  Our solution is to split the private signing key into shares. The private key is never reconstructed in any plaintext form.  Instead, a new certificate is generated using a multi-party computation protocol where the private key is only reconstructed in encrypted form within a secure protocol.  Secure multi-party computation (MPC) enables two or more parties to collaboratively compute a function without revealing their individual inputs.  We use MPC to enable a key signing operation that depends on a private key, without ever exposing that private key. The key itself is never visible to any party in unencrypted form, and never stored on any physical device.

The shares could be distributed among multiple hosts operated by the same CA to mitigate the risk of compromise when one of the keys is stolen.  To further reduce mistakes and insider risks, the shares could be distributed across two independently-operated CAs with their own procedures of vetting so that scrutiny from multiple parties would reduce the chance of mistakes such as those made by Symantec~\cite{symantec_issues_wiki} and Let's Encrypt~\cite{lets_encrypt_paypal}. The final scenario supports organizations that do not want to place their identity in the hands of a CA. The private key is split between the CA and the organization, requiring involvement of both parties to generate the joint public key the first time and a new certificate at each subsequent signing. This joint public key is signed by a pair of two independent CAs. This design allows organizations to control the generation of any certificate for their domain, and prevents a CA from issuing certificates to third-parties without the permission of the domain holders. 
However, adopting our scheme would require some modifications to the current certificate deployment model. For first two scenarios, where the organization is not involved in its certificate signing, the joint public key used in the signing can be baked into the client browser to verify the certificate signature. For the third scenario, where the organization is also involved in the signing, baking the joint key into the client browser can be expensive, as there could be many such keys, one for each organization. We could employ certificate transparency logs~\cite{certificate_transparency} and public key pinning~\cite{public_key_pinning} to solve this problem. Further discussion regarding this can be found in Section~\ref{sec:discussion}.
%\dnote{we are relying on some external browser mechanism for the generic CA-signed certs to not be accepted by the browser. I'm not sure if we have a specific mechanism in mind for this already, but need to be clear what this relies on.}

In this work, we demonstrate the practicality of a decentralized CA by implementing certificate signing as a secure two-party computation using the Elliptic Curve Digital Signature Algorithm (ECDSA) on a 192-bit curve. The main cost of signing depends on the cost of bandwidth between the participating CAs. If both are in the same data center where in-center bandwidth is free, the computational cost to sign one certificate on Amazon AWS EC2 c4.2xlarge nodes using Yao's garbled circuits protocol with semi-honest security is 28.2-32.6 cents; for active security using dual execution, this cost approximately doubles to 63.3-65 cents. Performing the signing with dual execution involves transferring 819.44 GiB, so at AWS prices for bandwidth this makes the cost per certificate up to \$17.07 for active security when nodes are running in different data centers.  Although this cost may be prohibitive for some purposes, for others (e.g., Symantec currently charges a \$500/year premium for ECC over RSA/DSA certificate) it is already economically viable.

\shortsection{Roadmap} We begin by providing a background on the certificate issuance process (Section~\ref{sec:certificate_issuance_process}), secure multi-party computation (Section~\ref{sec:multi_party_computation}), and the ECDSA signing algorithm (Section~\ref{sec:ecdsa}). In section~\ref{sec:design}, we explain the design of our decentralized certificate authorities. Section~\ref{sec:implementation} provides details on our implementation, followed by the performance measurements in Section~\ref{sec:performance}. Finally, we end our paper discussing the adaptability of our design in Section~\ref{sec:discussion}.